## 0e 绕过

简单来说, 就是一些特殊的字符串, 经过md5加密后, 得到的字符串是`0e`开头的. 这里直接记录一些常规的 0e 绕过.

> [!note]
> 
> QNKCDZO
> 240610708
> s878926199a
> s155964671a
> s214587387a
> s214587387a

如下, md5若判断时为true:

![[attachments/Pasted image 20250411222550.png]]

## 数组绕过

查阅文档, 发现php的md5函数定义如下:

```php
md5(string, raw)
```

如果传入的需要转换为md5的内容为非字符串, 则会产生报错, 但同时, 会返回 `null`.

![[attachments/Pasted image 20250411223102.png]]

那么, 如果两个 `null`, 自然是相等的, 这样就实现了绕过.

>[!info]
> 一般来说, 代码都会在前面加上一句 `error_reporting(0);` 来关闭报错, 这个时候再次查看, 显示则会正常很多.
> 
> ![[attachments/Pasted image 20250411223402.png]]

一般来说, 这个可以绕过普通的强类型判断, 例如如下php代码:

```php
<?php
error_reporting(0);
$a []= 123;
$b []= 456;
echo md5($a) === md5($b) ? "相等" : "不相等";
?>
```

输出**相等**; 不过, 如果我们对传入的内容进行字符串强制转换呢? 这里就无法正常绕过了.

## 强类型绕过

接上文, 可能会遇到这样的情况:

![[attachments/Pasted image 20250411224214.png]]

两个强类型, 这个时候, 只能是md5碰撞得到的一些答案可以绕过去了. 下面直接记录一些MD5碰撞出来的字符串, 可以绕过这种类型的判断.

> [!note]
> \$a = `"\x4d\xc9\x68\xff\x0e\xe3\x5c\x20\x95\x72\xd4\x77\x7b\x72\x15\x87\xd3\x6f\xa7\xb2\x1b\xdc\x56\xb7\x4a\x3d\xc0\x78\x3e\x7b\x95\x18\xaf\xbf\xa2\x00\xa8\x28\x4b\xf3\x6e\x8e\x4b\x55\xb3\x5f\x42\x75\x93\xd8\x49\x67\x6d\xa0\xd1\x55\x5d\x83\x60\xfb\x5f\x07\xfe\xa2"`
> \$b = `"\x4d\xc9\x68\xff\x0e\xe3\x5c\x20\x95\x72\xd4\x77\x7b\x72\x15\x87\xd3\x6f\xa7\xb2\x1b\xdc\x56\xb7\x4a\x3d\xc0\x78\x3e\x7b\x95\x18\xaf\xbf\xa2\x02\xa8\x28\x4b\xf3\x6e\x8e\x4b\x55\xb3\x5f\x42\x75\x93\xd8\x49\x67\x6d\xa0\xd1\xd5\x5d\x83\x60\xfb\x5f\x07\xfe\xa2"`
> ---
> \$data1 = `"\xd1\x31\xdd\x02\xc5\xe6\xee\xc4\x69\x3d\x9a\x06\x98\xaf\xf9\x5c\x2f\xca\xb5\x07\x12\x46\x7e\xab\x40\x04\x58\x3e\xb8\xfb\x7f\x89\x55\xad\x34\x06\x09\xf4\xb3\x02\x83\xe4\x88\x83\x25\xf1\x41\x5a\x08\x51\x25\xe8\xf7\xcd\xc9\x9f\xd9\x1d\xbd\x72\x80\x37\x3c\x5b\xd8\x82\x3e\x31\x56\x34\x8f\x5b\xae\x6d\xac\xd4\x36\xc9\x19\xc6\xdd\x53\xe2\x34\x87\xda\x03\xfd\x02\x39\x63\x06\xd2\x48\xcd\xa0\xe9\x9f\x33\x42\x0f\x57\x7e\xe8\xce\x54\xb6\x70\x80\x28\x0d\x1e\xc6\x98\x21\xbc\xb6\xa8\x83\x93\x96\xf9\x65\xab\x6f\xf7\x2a\x70"`
> \$data2 = `"\xd1\x31\xdd\x02\xc5\xe6\xee\xc4\x69\x3d\x9a\x06\x98\xaf\xf9\x5c\x2f\xca\xb5\x87\x12\x46\x7e\xab\x40\x04\x58\x3e\xb8\xfb\x7f\x89\x55\xad\x34\x06\x09\xf4\xb3\x02\x83\xe4\x88\x83\x25\x71\x41\x5a\x08\x51\x25\xe8\xf7\xcd\xc9\x9f\xd9\x1d\xbd\xf2\x80\x37\x3c\x5b\xd8\x82\x3e\x31\x56\x34\x8f\x5b\xae\x6d\xac\xd4\x36\xc9\x19\xc6\xdd\x53\xe2\xb4\x87\xda\x03\xfd\x02\x39\x63\x06\xd2\x48\xcd\xa0\xe9\x9f\x33\x42\x0f\x57\x7e\xe8\xce\x54\xb6\x70\x80\xa8\x0d\x1e\xc6\x98\x21\xbc\xb6\xa8\x83\x93\x96\xf9\x65\x2b\x6f\xf7\x2a\x70"`

![[attachments/Pasted image 20250411225925.png]]

如果需要, 你可以使用一个工具来获取两个MD5值相同的, 但是内容不同的字符串. 

具体工具使用可以查看文章: [[../工具汇总/fastcoll MD5 碰撞|fastcoll MD5 碰撞]]
## \$a == md5($a)

遇到了直接使用这个特殊字符串就行, `0e215962017`. 具体示例如下:

```php
<?php
$a = "0e215962017";

if ($a == md5($a)){
	echo "绕过成功";
} else {
	echo "WAF";
}
?>
// 输出: 绕过成功
```

## md5 与 SQL 注入

这是一个神奇的字符串: `ffifdyop`. 经过md5加密后, 可以得到: `276f722736c95d99e921722cf9ed621c`, 随后再次转换为字符串, 可以得到这样一个内容: `'or'6<乱码>`

那么, 如果传入的密码需要进行md5加密, 则可以直接传入这个特殊字符串, 实现sql注入.

关于这个字符串的用法, 可以直接看看例题: [BJDCTF 2020 easy_md5](https://www.nssctf.cn/problem/713)
